/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    SportsScramble              |
 * | Version: 1                           |
 * | Date:    09/09/2024                  |
 * ----------------------------------------
 */

#include "../pch.h"
#include <cstdint>
#include <vector>
#include <string>
#include <locale>
#include <unordered_set>
#include "Headers/Global_DEFINES.h"
#include "Headers/BasicTypes.h"
#include "Headers/CoreUObject_UFunction.h"
#include "Headers/AnimGraphRuntime_ENUMS.h"
#include "Headers/AnimGraphRuntime_PARAMS.h"
#include "Headers/AnimGraphRuntime_UAnimCustomInstance.h"
#include "Headers/AnimGraphRuntime_UAnimNotify_PlayMontageNotify.h"
#include "Headers/AnimGraphRuntime_UAnimNotify_PlayMontageNotifyWindow.h"
#include "Headers/AnimGraphRuntime_UAnimSequencerInstance.h"
#include "Headers/AnimGraphRuntime_UKismetAnimationLibrary.h"
#include "Headers/AnimGraphRuntime_UPlayMontageCallbackProxy.h"

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::AnimGraphRuntime
{
    // --------------------------------------------------
    // # Structs functions
    // --------------------------------------------------
    /**
     * Function:
     *         RVA    -> 0x00EEF2C0
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_TwoBoneIK
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         CoreUObject::FVector                               RootPos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               JointPos                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               EndPos                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               JointTarget                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               Effector                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               OutJointPos                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               OutEndPos                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bAllowStretching                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              StartStretchRatio                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              MaxStretchScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UKismetAnimationLibrary::STATIC_K2_TwoBoneIK(const CoreUObject::FVector& RootPos, const CoreUObject::FVector& JointPos, const CoreUObject::FVector& EndPos, const CoreUObject::FVector& JointTarget, const CoreUObject::FVector& Effector, CoreUObject::FVector* OutJointPos, CoreUObject::FVector* OutEndPos, bool bAllowStretching, float StartStretchRatio, float MaxStretchScale)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_TwoBoneIK");
        
        UKismetAnimationLibrary_K2_TwoBoneIK_Params params {};
        params.RootPos = RootPos;
        params.JointPos = JointPos;
        params.EndPos = EndPos;
        params.JointTarget = JointTarget;
        params.Effector = Effector;
        params.bAllowStretching = bAllowStretching;
        params.StartStretchRatio = StartStretchRatio;
        params.MaxStretchScale = MaxStretchScale;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutJointPos != nullptr)
            *OutJointPos = params.OutJointPos;
        if (OutEndPos != nullptr)
            *OutEndPos = params.OutEndPos;
    }

    /**
     * Function:
     *         RVA    -> 0x00EEF010
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_MakePerlinNoiseVectorAndRemap
     *         Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMinX                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMaxX                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMinY                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMaxY                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMinZ                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMaxZ                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    CoreUObject::FVector UKismetAnimationLibrary::STATIC_K2_MakePerlinNoiseVectorAndRemap(float X, float Y, float Z, float RangeOutMinX, float RangeOutMaxX, float RangeOutMinY, float RangeOutMaxY, float RangeOutMinZ, float RangeOutMaxZ)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_MakePerlinNoiseVectorAndRemap");
        
        UKismetAnimationLibrary_K2_MakePerlinNoiseVectorAndRemap_Params params {};
        params.X = X;
        params.Y = Y;
        params.Z = Z;
        params.RangeOutMinX = RangeOutMinX;
        params.RangeOutMaxX = RangeOutMaxX;
        params.RangeOutMinY = RangeOutMinY;
        params.RangeOutMaxY = RangeOutMaxY;
        params.RangeOutMinZ = RangeOutMinZ;
        params.RangeOutMaxZ = RangeOutMaxZ;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x00EEEF00
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_MakePerlinNoiseAndRemap
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMax                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UKismetAnimationLibrary::STATIC_K2_MakePerlinNoiseAndRemap(float Value, float RangeOutMin, float RangeOutMax)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_MakePerlinNoiseAndRemap");
        
        UKismetAnimationLibrary_K2_MakePerlinNoiseAndRemap_Params params {};
        params.Value = Value;
        params.RangeOutMin = RangeOutMin;
        params.RangeOutMax = RangeOutMax;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x00EEEC80
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_LookAt
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         CoreUObject::FTransform                            CurrentTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               TargetPosition                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               LookAtVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bUseUpVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               UpVector                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              ClampConeInDegree                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FTransform                            ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
     */
    CoreUObject::FTransform UKismetAnimationLibrary::STATIC_K2_LookAt(const CoreUObject::FTransform& CurrentTransform, const CoreUObject::FVector& TargetPosition, const CoreUObject::FVector& LookAtVector, bool bUseUpVector, const CoreUObject::FVector& UpVector, float ClampConeInDegree)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_LookAt");
        
        UKismetAnimationLibrary_K2_LookAt_Params params {};
        params.CurrentTransform = CurrentTransform;
        params.TargetPosition = TargetPosition;
        params.LookAtVector = LookAtVector;
        params.bUseUpVector = bUseUpVector;
        params.UpVector = UpVector;
        params.ClampConeInDegree = ClampConeInDegree;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x00EEE9C0
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_DistanceBetweenTwoSocketsAndMapRange
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::USkeletalMeshComponent*                    Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  SocketOrBoneNameA                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::ERelativeTransformSpace                    SocketSpaceA                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  SocketOrBoneNameB                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::ERelativeTransformSpace                    SocketSpaceB                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bRemapRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              InRangeMin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              InRangeMax                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              OutRangeMin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              OutRangeMax                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UKismetAnimationLibrary::STATIC_K2_DistanceBetweenTwoSocketsAndMapRange(Engine::USkeletalMeshComponent* Component, const BasicTypes::FName& SocketOrBoneNameA, Engine::ERelativeTransformSpace SocketSpaceA, const BasicTypes::FName& SocketOrBoneNameB, Engine::ERelativeTransformSpace SocketSpaceB, bool bRemapRange, float InRangeMin, float InRangeMax, float OutRangeMin, float OutRangeMax)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_DistanceBetweenTwoSocketsAndMapRange");
        
        UKismetAnimationLibrary_K2_DistanceBetweenTwoSocketsAndMapRange_Params params {};
        params.Component = Component;
        params.SocketOrBoneNameA = SocketOrBoneNameA;
        params.SocketSpaceA = SocketSpaceA;
        params.SocketOrBoneNameB = SocketOrBoneNameB;
        params.SocketSpaceB = SocketSpaceB;
        params.bRemapRange = bRemapRange;
        params.InRangeMin = InRangeMin;
        params.InRangeMax = InRangeMax;
        params.OutRangeMin = OutRangeMin;
        params.OutRangeMax = OutRangeMax;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x00EEE8C0
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_DirectionBetweenSockets
     *         Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::USkeletalMeshComponent*                    Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  SocketOrBoneNameFrom                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  SocketOrBoneNameTo                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    CoreUObject::FVector UKismetAnimationLibrary::STATIC_K2_DirectionBetweenSockets(Engine::USkeletalMeshComponent* Component, const BasicTypes::FName& SocketOrBoneNameFrom, const BasicTypes::FName& SocketOrBoneNameTo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_DirectionBetweenSockets");
        
        UKismetAnimationLibrary_K2_DirectionBetweenSockets_Params params {};
        params.Component = Component;
        params.SocketOrBoneNameFrom = SocketOrBoneNameFrom;
        params.SocketOrBoneNameTo = SocketOrBoneNameTo;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x00EEF870
     *         Name   -> Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnNotifyEndReceived
     *         Flags  -> (Final, Native, Protected, HasOutParms)
     * Parameters:
     *         BasicTypes::FName                                  NotifyName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::FBranchingPointNotifyPayload               BranchingPointNotifyPayload                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UPlayMontageCallbackProxy::OnNotifyEndReceived(const BasicTypes::FName& NotifyName, const Engine::FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnNotifyEndReceived");
        
        UPlayMontageCallbackProxy_OnNotifyEndReceived_Params params {};
        params.NotifyName = NotifyName;
        params.BranchingPointNotifyPayload = BranchingPointNotifyPayload;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x00EEF790
     *         Name   -> Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnNotifyBeginReceived
     *         Flags  -> (Final, Native, Protected, HasOutParms)
     * Parameters:
     *         BasicTypes::FName                                  NotifyName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::FBranchingPointNotifyPayload               BranchingPointNotifyPayload                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UPlayMontageCallbackProxy::OnNotifyBeginReceived(const BasicTypes::FName& NotifyName, const Engine::FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnNotifyBeginReceived");
        
        UPlayMontageCallbackProxy_OnNotifyBeginReceived_Params params {};
        params.NotifyName = NotifyName;
        params.BranchingPointNotifyPayload = BranchingPointNotifyPayload;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x00EEF6C0
     *         Name   -> Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnMontageEnded
     *         Flags  -> (Final, Native, Protected)
     * Parameters:
     *         Engine::UAnimMontage*                              Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UPlayMontageCallbackProxy::OnMontageEnded(Engine::UAnimMontage* Montage, bool bInterrupted)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnMontageEnded");
        
        UPlayMontageCallbackProxy_OnMontageEnded_Params params {};
        params.Montage = Montage;
        params.bInterrupted = bInterrupted;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x00EEF5F0
     *         Name   -> Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnMontageBlendingOut
     *         Flags  -> (Final, Native, Protected)
     * Parameters:
     *         Engine::UAnimMontage*                              Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UPlayMontageCallbackProxy::OnMontageBlendingOut(Engine::UAnimMontage* Montage, bool bInterrupted)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnMontageBlendingOut");
        
        UPlayMontageCallbackProxy_OnMontageBlendingOut_Params params {};
        params.Montage = Montage;
        params.bInterrupted = bInterrupted;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x00EEE740
     *         Name   -> Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.CreateProxyObjectForPlayMontage
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable)
     * Parameters:
     *         Engine::USkeletalMeshComponent*                    InSkeletalMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::UAnimMontage*                              MontageToPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              StartingPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  StartingSection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::UPlayMontageCallbackProxy*       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::UPlayMontageCallbackProxy* UPlayMontageCallbackProxy::STATIC_CreateProxyObjectForPlayMontage(Engine::USkeletalMeshComponent* InSkeletalMeshComponent, Engine::UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, const BasicTypes::FName& StartingSection)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.CreateProxyObjectForPlayMontage");
        
        UPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage_Params params {};
        params.InSkeletalMeshComponent = InSkeletalMeshComponent;
        params.MontageToPlay = MontageToPlay;
        params.PlayRate = PlayRate;
        params.StartingPosition = StartingPosition;
        params.StartingSection = StartingSection;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
