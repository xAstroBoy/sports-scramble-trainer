/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    SportsScramble              |
 * | Version: 1                           |
 * | Date:    09/09/2024                  |
 * ----------------------------------------
 */

#include "../pch.h"
#include <cstdint>
#include <vector>
#include <string>
#include <locale>
#include <unordered_set>
#include "Headers/Global_DEFINES.h"
#include "Headers/BasicTypes.h"
#include "Headers/CoreUObject_UFunction.h"
#include "Headers/BasicTypes_ENUMS.h"
#include "Headers/BasicTypes_FTextData.h"
#include "Headers/Engine_UWorld.h"
#include "Headers/BasicTypes_FString.h"
#include "Headers/BasicTypes_FUObjectItem.h"
#include "Headers/BasicTypes_TUObjectArray.h"
#include "Headers/BasicTypes_FNameEntry.h"
#include "Headers/BasicTypes_FName.h"
#include "Headers/BasicTypes_FScriptInterface.h"
#include "Headers/BasicTypes_FText.h"
#include "Headers/BasicTypes_FSoftObjectPtr.h"
#include "Headers/BasicTypes_FWeakObjectPtr.h"

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::BasicTypes
{
    // --------------------------------------------------
    // # Structs Static Fields
    // --------------------------------------------------
    BasicTypes::TNameEntryArray*                                 FName::GNames = nullptr;

    // --------------------------------------------------
    // # Global functions
    // --------------------------------------------------
    /**
     * Initialize SDK
     */
    bool InitSdk(const uintptr_t gNamesOffset, const uintptr_t gObjectsOffset, const uintptr_t gWorldOffset, const std::wstring& moduleName)
    {
        auto mBaseAddress = reinterpret_cast<uintptr_t>(GetModuleHandleW(moduleName.c_str()));
        if (mBaseAddress == NULL) return false;
        
        CoreUObject::UObject::GObjects = reinterpret_cast<BasicTypes::TUObjectArray*>(mBaseAddress + gObjectsOffset);
        BasicTypes::FName::GNames = reinterpret_cast<BasicTypes::TNameEntryArray*>(mBaseAddress + gNamesOffset);
        Engine::UWorld::GWorld = reinterpret_cast<Engine::UWorld**>(mBaseAddress + gWorldOffset);
        
        return true;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         bool                                               
     */
    bool InitSdk()
    {
        return InitSdk(NAMES_OFFSET, OBJECTS_OFFSET, WORLD_OFFSET, GAME_MODULE_NAME);
    }

    // --------------------------------------------------
    // # Structs functions
    // --------------------------------------------------
    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     */
    FString::FString()
    {

    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         const wchar_t*                                     other
     */
    FString::FString(const wchar_t* other)
    {
        _max = _count = *other ? static_cast<int32_t>(std::wcslen(other)) + 1 : 0;
        if (_count) _data = const_cast<wchar_t*>(other);
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         const wchar_t*                                     
     */
    const wchar_t* FString::wc_str() const
    {
        return _data;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         const char*                                        
     */
    const char* FString::c_str() const
    {
        return (const char*)_data;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         bool                                               
     */
    bool FString::IsValid() const
    {
        return _data != nullptr;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::string                                        
     */
    std::string FString::ToString() const
    {
        size_t length = std::wcslen(_data);
        std::string str(length, '\0');
        std::use_facet<std::ctype<wchar_t>>(std::locale()).narrow(_data, _data + length, '?', str.data());
        return str;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::wstring                                       
     */
    std::wstring FString::ToWString() const
    {
        std::wstring str(_data);
        return str;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         bool                                               
     */
    bool FUObjectItem::IsUnreachable()
    {
        return !!(Flags & static_cast<std::underlying_type_t<ObjectFlags>>(ObjectFlags::Unreachable));
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         bool                                               
     */
    bool FUObjectItem::IsPendingKill()
    {
        return !!(Flags & static_cast<std::underlying_type_t<ObjectFlags>>(ObjectFlags::PendingKill));
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         int32_t                                            
     */
    int32_t TUObjectArray::Count() const
    {
        return NumElements;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         int32_t                                            
     */
    int32_t TUObjectArray::Max() const
    {
        return MaxElements;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         bool                                               
     *         int32_t                                            Index
     */
    bool TUObjectArray::IsValidIndex(int32_t Index) const
    {
        return Index < Count() && Index >= 0;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         FUObjectItem*                                      
     *         int32_t                                            Index
     */
    FUObjectItem* TUObjectArray::GetObjectPtr(int32_t Index) const
    {
        const int32_t ChunkIndex = Index / NumElementsPerChunk;
        const int32_t WithinChunkIndex = Index % NumElementsPerChunk;
        if (!IsValidIndex(Index)) return nullptr;
        if (ChunkIndex > NumChunks) return nullptr;
        if (Index > MaxElements) return nullptr;
        FUObjectItem* Chunk = Objects[ChunkIndex];
        if (!Chunk) return nullptr;
        return Chunk + WithinChunkIndex;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         CoreUObject::UObject*                              
     *         int32_t                                            index
     */
    CoreUObject::UObject* TUObjectArray::GetByIndex(int32_t index) const
    {
        const FUObjectItem* itemPtr = GetObjectPtr(index);
        if (!itemPtr) return nullptr;
        return itemPtr->Object;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         BasicTypes::FUObjectItem*                          
     *         int32_t                                            index
     */
    BasicTypes::FUObjectItem* TUObjectArray::GetItemByIndex(int32_t index) const
    {
        FUObjectItem* itemPtr = GetObjectPtr(index);
        if (!itemPtr) return nullptr;
        return itemPtr;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         CoreUObject::UObject*                              
     *         int32_t                                            i
     */
    CoreUObject::UObject* TUObjectArray::operator[](int32_t i)
    {
        return GetByIndex(i);
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         const CoreUObject::UObject*                        
     *         int32_t                                            i
     */
    const CoreUObject::UObject* TUObjectArray::operator[](int32_t i) const
    {
        return GetByIndex(i);
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         const int32_t                                      
     */
    const int32_t FNameEntry::GetIndex() const
    {
        return Index >> NAME_INDEX_SHIFT;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         bool                                               
     */
    bool FNameEntry::IsWide() const
    {
        return Index & NAME_WIDE_MASK;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::string                                        
     */
    std::string FNameEntry::GetAnsiName() const
    {
        return std::string(AnsiName);
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::wstring                                       
     */
    std::wstring FNameEntry::GetWideName() const
    {
        return std::wstring(WideName);
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::string                                        
     */
    std::string FNameEntry::GetName() const
    {
        return GetAnsiName();
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     */
    FName::FName()
    {
        ComparisonIndex = 0;
        Number = 0;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         int32_t                                            i
     */
    FName::FName(int32_t i)
    {
        ComparisonIndex = i;
        Number = 0;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         const char*                                        nameToFind
     */
    FName::FName(const char* nameToFind)
    {
        Number = 0;
        static std::unordered_set<int> cache;
        for (auto i : cache)
        {
            if (GetGlobalNames()[i]->GetAnsiName() == nameToFind)
            {
                ComparisonIndex = i;
                #ifdef FNAME_POOL_WITH_CASE_PRESERVING_NAME
                DisplayIndex = i;
                #endif
                return;
            }
        }
        
        #ifdef FNAME_POOL
        uintptr_t lastFNameAddress = NULL;
        uint32_t curComparisonId = 0;
        for (FNameEntry* name = GetGlobalNames().GetNext(lastFNameAddress, &curComparisonId); name != nullptr; name = GetGlobalNames().GetNext(lastFNameAddress, &curComparisonId))
        {
            if (name->GetAnsiName() == nameToFind)
            {
                cache.insert(curComparisonId);
                ComparisonIndex = curComparisonId;
                #ifdef FNAME_POOL_WITH_CASE_PRESERVING_NAME
                DisplayIndex = curComparisonId;
                #endif
                return;
            }
        }
        #else
        for (int32_t i = 0; i < GetGlobalNames().Count(); ++i)
        {
            if (GetGlobalNames()[i]->GetAnsiName() == nameToFind)
            {
                cache.insert(i);
                ComparisonIndex = i;
                return;
            }
        }
        #endif
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         const wchar_t*                                     nameToFind
     */
    FName::FName(const wchar_t* nameToFind)
    {
        Number = 0;
        static std::unordered_set<int> cache;
        for (auto i : cache)
        {
            if (GetGlobalNames()[i]->GetWideName() == nameToFind)
            {
                ComparisonIndex = i;
                #ifdef FNAME_POOL_WITH_CASE_PRESERVING_NAME
                DisplayIndex = i;
                #endif
                return;
            }
        }
        
        #ifdef FNAME_POOL
        uintptr_t lastFNameAddress = NULL;
        uint32_t curComparisonId = 0;
        for (FNameEntry* name = GetGlobalNames().GetNext(lastFNameAddress, &curComparisonId); name != nullptr; name = GetGlobalNames().GetNext(lastFNameAddress, &curComparisonId))
        {
            if (name->GetWideName() == nameToFind)
            {
                cache.insert(curComparisonId);
                ComparisonIndex = curComparisonId;
                #ifdef FNAME_POOL_WITH_CASE_PRESERVING_NAME
                DisplayIndex = curComparisonId;
                #endif
                return;
            }
        }
        #else
        for (int32_t i = 0; i < GetGlobalNames().Count(); ++i)
        {
            if (GetGlobalNames()[i]->GetWideName() == nameToFind)
            {
                cache.insert(i);
                ComparisonIndex = i;
                return;
            }
        }
        #endif
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         BasicTypes::TNameEntryArray&                       
     */
    BasicTypes::TNameEntryArray& FName::GetGlobalNames()
    {
        return *GNames;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::string                                        
     */
    std::string FName::GetNameA() const
    {
        return GetGlobalNames()[ComparisonIndex]->GetAnsiName();
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::wstring                                       
     */
    std::wstring FName::GetNameW() const
    {
        return GetGlobalNames()[ComparisonIndex]->GetWideName();
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::string                                        
     */
    std::string FName::ToString() const
    {
        return GetNameA();
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         bool                                               
     *         const BasicTypes::FName&                           other
     */
    bool FName::operator==(const BasicTypes::FName& other) const
    {
        return ComparisonIndex == other.ComparisonIndex && Number == other.Number;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         CoreUObject::UObject*                              
     */
    CoreUObject::UObject* FScriptInterface::GetObjectPtr() const
    {
        return ObjectPointer;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         CoreUObject::UObject*&                             
     */
    CoreUObject::UObject*& FScriptInterface::GetObjectRef()
    {
        return ObjectPointer;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         void*                                              
     */
    void* FScriptInterface::GetInterface() const
    {
        return ObjectPointer != nullptr ? InterfacePointer : nullptr;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         wchar_t*                                           
     */
    wchar_t* FText::Get() const
    {
        return Data != nullptr ? Data->Name : nullptr;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::string                                        
     */
    std::string FText::ToString() const
    {
        wchar_t* name = Get();
        if (!name)
            return "NOT FOUND";
        
        size_t length = std::wcslen(name);
        std::string str(length, '\0');
        std::use_facet<std::ctype<wchar_t>>(std::locale()).narrow(name, name + length, '?', str.data());
        
        return str;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::wstring                                       
     */
    std::wstring FText::ToWString() const
    {
        wchar_t* name = Get();
        if (!name)
            return L"NOT FOUND";
        
        std::wstring str(name);
        return str;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         BasicTypes::FName                                  
     */
    BasicTypes::FName FSoftObjectPtr::GetAssetPathName() const
    {
        return ObjectID.AssetPathName;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         BasicTypes::FString                                
     */
    BasicTypes::FString FSoftObjectPtr::GetSubPathString() const
    {
        return ObjectID.SubPathString;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::string                                        
     */
    std::string FSoftObjectPtr::GetAssetPathNameStr() const
    {
        return ObjectID.AssetPathName.ToString();
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         std::string                                        
     */
    std::string FSoftObjectPtr::GetSubPathStringStr() const
    {
        return ObjectID.SubPathString.ToString();
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         bool                                               
     *         BasicTypes::FUObjectItem*                          objectItem
     */
    bool FWeakObjectPtr::SerialNumbersMatch(BasicTypes::FUObjectItem* objectItem) const
    {
        return objectItem->SerialNumber == ObjectSerialNumber;
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         bool                                               
     */
    bool FWeakObjectPtr::IsValid() const
    {
        if (ObjectSerialNumber == 0 || ObjectIndex < 0)
        	return false;
        
        auto ObjectItem = CoreUObject::UObject::GetGlobalObjects().GetItemByIndex(ObjectIndex);
        if (!ObjectItem)
        	return false;
        
        if (!SerialNumbersMatch(ObjectItem))
        	return false;
        
        return !(ObjectItem->IsUnreachable() || ObjectItem->IsPendingKill());
    }

    /**
     * Function:
     *         RVA    -> 0x00000000
     *         Name   -> 
     *         Flags  -> ()
     * Parameters:
     *         CoreUObject::UObject*                              
     */
    CoreUObject::UObject* FWeakObjectPtr::Get() const
    {
        if (!IsValid())
        	return nullptr;
        
        auto ObjectItem = CoreUObject::UObject::GetGlobalObjects().GetItemByIndex(ObjectIndex);
        if (!ObjectItem)
        	return nullptr;
        
        return ObjectItem->Object;
    }

}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
