/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    SportsScramble              |
 * | Version: 1                           |
 * | Date:    10/14/2024                  |
 * ----------------------------------------
 */

#include "pch.h"
#include <cstdint>
#include <vector>
#include <string>
#include <locale>
#include <unordered_set>
#include "Headers/Global_DEFINES.h"
#include "Headers/BasicTypes.h"
#include "Headers/CoreUObject_UFunction.h"
#include "Headers/GameplayTags_ENUMS.h"
#include "Headers/GameplayTags_PARAMS.h"
#include "Headers/GameplayTags_UBlueprintGameplayTagLibrary.h"
#include "Headers/GameplayTags_UGameplayTagsDeveloperSettings.h"
#include "Headers/GameplayTags_UEditableGameplayTagQueryExpression_NoTagsMatch.h"
#include "Headers/GameplayTags_UEditableGameplayTagQueryExpression_AnyExprMatch.h"
#include "Headers/GameplayTags_UEditableGameplayTagQueryExpression_AllExprMatch.h"
#include "Headers/GameplayTags_UEditableGameplayTagQueryExpression_NoExprMatch.h"
#include "Headers/GameplayTags_UGameplayTagsManager.h"
#include "Headers/GameplayTags_UGameplayTagsList.h"
#include "Headers/GameplayTags_URestrictedGameplayTagsList.h"
#include "Headers/GameplayTags_UGameplayTagsSettings.h"
#include "Headers/GameplayTags_IGameplayTagAssetInterface.h"
#include "Headers/GameplayTags_UEditableGameplayTagQuery.h"
#include "Headers/GameplayTags_UEditableGameplayTagQueryExpression.h"
#include "Headers/GameplayTags_UEditableGameplayTagQueryExpression_AnyTagsMatch.h"
#include "Headers/GameplayTags_UEditableGameplayTagQueryExpression_AllTagsMatch.h"

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::GameplayTags
{
    // --------------------------------------------------
    // # Structs functions
    // --------------------------------------------------
    /**
     * Function:
     *         RVA    -> 0x01055210
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.RemoveGameplayTag
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTag                         Tag                                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_RemoveGameplayTag(GameplayTags::FGameplayTagContainer* TagContainer, const GameplayTags::FGameplayTag& Tag)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.RemoveGameplayTag");
        
        UBlueprintGameplayTagLibrary_RemoveGameplayTag_Params params {};
        params.Tag = Tag;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (TagContainer != nullptr)
            *TagContainer = params.TagContainer;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x010550F0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.NotEqual_TagTag
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTag                         A                                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FString                                B                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_NotEqual_TagTag(const GameplayTags::FGameplayTag& A, const BasicTypes::FString& B)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.NotEqual_TagTag");
        
        UBlueprintGameplayTagLibrary_NotEqual_TagTag_Params params {};
        params.A = A;
        params.B = B;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054F80
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.NotEqual_TagContainerTagContainer
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                A                                                          (Parm, NativeAccessSpecifierPublic)
     *         BasicTypes::FString                                B                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_NotEqual_TagContainerTagContainer(const GameplayTags::FGameplayTagContainer& A, const BasicTypes::FString& B)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.NotEqual_TagContainerTagContainer");
        
        UBlueprintGameplayTagLibrary_NotEqual_TagContainerTagContainer_Params params {};
        params.A = A;
        params.B = B;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054E30
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.NotEqual_GameplayTagContainer
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                A                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagContainer                B                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_NotEqual_GameplayTagContainer(const GameplayTags::FGameplayTagContainer& A, const GameplayTags::FGameplayTagContainer& B)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.NotEqual_GameplayTagContainer");
        
        UBlueprintGameplayTagLibrary_NotEqual_GameplayTagContainer_Params params {};
        params.A = A;
        params.B = B;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054D70
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.NotEqual_GameplayTag
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTag                         A                                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTag                         B                                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_NotEqual_GameplayTag(const GameplayTags::FGameplayTag& A, const GameplayTags::FGameplayTag& B)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.NotEqual_GameplayTag");
        
        UBlueprintGameplayTagLibrary_NotEqual_GameplayTag_Params params {};
        params.A = A;
        params.B = B;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054C80
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MatchesTag
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTag                         TagOne                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTag                         TagTwo                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bExactMatch                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_MatchesTag(const GameplayTags::FGameplayTag& TagOne, const GameplayTags::FGameplayTag& TagTwo, bool bExactMatch)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MatchesTag");
        
        UBlueprintGameplayTagLibrary_MatchesTag_Params params {};
        params.TagOne = TagOne;
        params.TagTwo = TagTwo;
        params.bExactMatch = bExactMatch;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054B40
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MatchesAnyTags
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTag                         TagOne                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagContainer                OtherContainer                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               bExactMatch                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_MatchesAnyTags(const GameplayTags::FGameplayTag& TagOne, const GameplayTags::FGameplayTagContainer& OtherContainer, bool bExactMatch)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MatchesAnyTags");
        
        UBlueprintGameplayTagLibrary_MatchesAnyTags_Params params {};
        params.TagOne = TagOne;
        params.OtherContainer = OtherContainer;
        params.bExactMatch = bExactMatch;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054A30
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MakeLiteralGameplayTagContainer
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                Value                                                      (Parm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagContainer                ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
     */
    GameplayTags::FGameplayTagContainer UBlueprintGameplayTagLibrary::STATIC_MakeLiteralGameplayTagContainer(const GameplayTags::FGameplayTagContainer& Value)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MakeLiteralGameplayTagContainer");
        
        UBlueprintGameplayTagLibrary_MakeLiteralGameplayTagContainer_Params params {};
        params.Value = Value;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x010549A0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MakeLiteralGameplayTag
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTag                         Value                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTag                         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    GameplayTags::FGameplayTag UBlueprintGameplayTagLibrary::STATIC_MakeLiteralGameplayTag(const GameplayTags::FGameplayTag& Value)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MakeLiteralGameplayTag");
        
        UBlueprintGameplayTagLibrary_MakeLiteralGameplayTag_Params params {};
        params.Value = Value;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054870
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MakeGameplayTagQuery
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagQuery                    TagQuery                                                   (Parm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagQuery                    ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
     */
    GameplayTags::FGameplayTagQuery UBlueprintGameplayTagLibrary::STATIC_MakeGameplayTagQuery(const GameplayTags::FGameplayTagQuery& TagQuery)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MakeGameplayTagQuery");
        
        UBlueprintGameplayTagLibrary_MakeGameplayTagQuery_Params params {};
        params.TagQuery = TagQuery;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x010547C0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MakeGameplayTagContainerFromTag
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTag                         SingleTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagContainer                ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
     */
    GameplayTags::FGameplayTagContainer UBlueprintGameplayTagLibrary::STATIC_MakeGameplayTagContainerFromTag(const GameplayTags::FGameplayTag& SingleTag)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MakeGameplayTagContainerFromTag");
        
        UBlueprintGameplayTagLibrary_MakeGameplayTagContainerFromTag_Params params {};
        params.SingleTag = SingleTag;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x010546F0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MakeGameplayTagContainerFromArray
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         BasicTypes::TArray<GameplayTags::FGameplayTag>     GameplayTags                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagContainer                ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
     */
    GameplayTags::FGameplayTagContainer UBlueprintGameplayTagLibrary::STATIC_MakeGameplayTagContainerFromArray(BasicTypes::TArray<GameplayTags::FGameplayTag> GameplayTags)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.MakeGameplayTagContainerFromArray");
        
        UBlueprintGameplayTagLibrary_MakeGameplayTagContainerFromArray_Params params {};
        params.GameplayTags = GameplayTags;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054670
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.IsGameplayTagValid
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTag                         GameplayTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_IsGameplayTagValid(const GameplayTags::FGameplayTag& GameplayTag)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.IsGameplayTagValid");
        
        UBlueprintGameplayTagLibrary_IsGameplayTagValid_Params params {};
        params.GameplayTag = GameplayTag;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054530
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.HasTag
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTag                         Tag                                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bExactMatch                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_HasTag(const GameplayTags::FGameplayTagContainer& TagContainer, const GameplayTags::FGameplayTag& Tag, bool bExactMatch)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.HasTag");
        
        UBlueprintGameplayTagLibrary_HasTag_Params params {};
        params.TagContainer = TagContainer;
        params.Tag = Tag;
        params.bExactMatch = bExactMatch;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054310
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.HasAnyTags
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagContainer                OtherContainer                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               bExactMatch                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_HasAnyTags(const GameplayTags::FGameplayTagContainer& TagContainer, const GameplayTags::FGameplayTagContainer& OtherContainer, bool bExactMatch)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.HasAnyTags");
        
        UBlueprintGameplayTagLibrary_HasAnyTags_Params params {};
        params.TagContainer = TagContainer;
        params.OtherContainer = OtherContainer;
        params.bExactMatch = bExactMatch;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x010540C0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.HasAllTags
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagContainer                OtherContainer                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               bExactMatch                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_HasAllTags(const GameplayTags::FGameplayTagContainer& TagContainer, const GameplayTags::FGameplayTagContainer& OtherContainer, bool bExactMatch)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.HasAllTags");
        
        UBlueprintGameplayTagLibrary_HasAllTags_Params params {};
        params.TagContainer = TagContainer;
        params.OtherContainer = OtherContainer;
        params.bExactMatch = bExactMatch;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01053FA0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.HasAllMatchingGameplayTags
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         BasicTypes::TScriptInterface<GameplayTags::IGameplayTagAssetInterface> TagContainerInterface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagContainer                OtherContainer                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_HasAllMatchingGameplayTags(const BasicTypes::TScriptInterface<GameplayTags::IGameplayTagAssetInterface>& TagContainerInterface, const GameplayTags::FGameplayTagContainer& OtherContainer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.HasAllMatchingGameplayTags");
        
        UBlueprintGameplayTagLibrary_HasAllMatchingGameplayTags_Params params {};
        params.TagContainerInterface = TagContainerInterface;
        params.OtherContainer = OtherContainer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01053E30
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.GetTagName
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTag                         GameplayTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    BasicTypes::FName UBlueprintGameplayTagLibrary::STATIC_GetTagName(const GameplayTags::FGameplayTag& GameplayTag)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.GetTagName");
        
        UBlueprintGameplayTagLibrary_GetTagName_Params params {};
        params.GameplayTag = GameplayTag;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01053CB0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.GetNumGameplayTagsInContainer
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UBlueprintGameplayTagLibrary::STATIC_GetNumGameplayTagsInContainer(const GameplayTags::FGameplayTagContainer& TagContainer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.GetNumGameplayTagsInContainer");
        
        UBlueprintGameplayTagLibrary_GetNumGameplayTagsInContainer_Params params {};
        params.TagContainer = TagContainer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01053BB0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.GetDebugStringFromGameplayTagContainer
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::FString                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    BasicTypes::FString UBlueprintGameplayTagLibrary::STATIC_GetDebugStringFromGameplayTagContainer(const GameplayTags::FGameplayTagContainer& TagContainer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.GetDebugStringFromGameplayTagContainer");
        
        UBlueprintGameplayTagLibrary_GetDebugStringFromGameplayTagContainer_Params params {};
        params.TagContainer = TagContainer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01053AE0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.GetDebugStringFromGameplayTag
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTag                         GameplayTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FString                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    BasicTypes::FString UBlueprintGameplayTagLibrary::STATIC_GetDebugStringFromGameplayTag(const GameplayTags::FGameplayTag& GameplayTag)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.GetDebugStringFromGameplayTag");
        
        UBlueprintGameplayTagLibrary_GetDebugStringFromGameplayTag_Params params {};
        params.GameplayTag = GameplayTag;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01053910
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.GetAllActorsOfClassMatchingTagQuery
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         CoreUObject::UObject*                              WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::AActor*                                    ActorClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagQuery                    GameplayTagQuery                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<Engine::AActor*>                OutActors                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UBlueprintGameplayTagLibrary::STATIC_GetAllActorsOfClassMatchingTagQuery(CoreUObject::UObject* WorldContextObject, Engine::AActor* ActorClass, const GameplayTags::FGameplayTagQuery& GameplayTagQuery, BasicTypes::TArray<Engine::AActor*>* OutActors)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.GetAllActorsOfClassMatchingTagQuery");
        
        UBlueprintGameplayTagLibrary_GetAllActorsOfClassMatchingTagQuery_Params params {};
        params.WorldContextObject = WorldContextObject;
        params.ActorClass = ActorClass;
        params.GameplayTagQuery = GameplayTagQuery;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutActors != nullptr)
            *OutActors = params.OutActors;
    }

    /**
     * Function:
     *         RVA    -> 0x010537C0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.EqualEqual_GameplayTagContainer
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                A                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagContainer                B                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_EqualEqual_GameplayTagContainer(const GameplayTags::FGameplayTagContainer& A, const GameplayTags::FGameplayTagContainer& B)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.EqualEqual_GameplayTagContainer");
        
        UBlueprintGameplayTagLibrary_EqualEqual_GameplayTagContainer_Params params {};
        params.A = A;
        params.B = B;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01053700
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.EqualEqual_GameplayTag
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTag                         A                                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTag                         B                                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_EqualEqual_GameplayTag(const GameplayTags::FGameplayTag& A, const GameplayTags::FGameplayTag& B)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.EqualEqual_GameplayTag");
        
        UBlueprintGameplayTagLibrary_EqualEqual_GameplayTag_Params params {};
        params.A = A;
        params.B = B;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01053620
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.DoesTagAssetInterfaceHaveTag
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         BasicTypes::TScriptInterface<GameplayTags::IGameplayTagAssetInterface> TagContainerInterface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTag                         Tag                                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_DoesTagAssetInterfaceHaveTag(const BasicTypes::TScriptInterface<GameplayTags::IGameplayTagAssetInterface>& TagContainerInterface, const GameplayTags::FGameplayTag& Tag)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.DoesTagAssetInterfaceHaveTag");
        
        UBlueprintGameplayTagLibrary_DoesTagAssetInterfaceHaveTag_Params params {};
        params.TagContainerInterface = TagContainerInterface;
        params.Tag = Tag;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x010534C0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.DoesContainerMatchTagQuery
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagQuery                    TagQuery                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlueprintGameplayTagLibrary::STATIC_DoesContainerMatchTagQuery(const GameplayTags::FGameplayTagContainer& TagContainer, const GameplayTags::FGameplayTagQuery& TagQuery)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.DoesContainerMatchTagQuery");
        
        UBlueprintGameplayTagLibrary_DoesContainerMatchTagQuery_Params params {};
        params.TagContainer = TagContainer;
        params.TagQuery = TagQuery;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x010533A0
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.BreakGameplayTagContainer
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                GameplayTagContainer                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<GameplayTags::FGameplayTag>     GameplayTags                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UBlueprintGameplayTagLibrary::STATIC_BreakGameplayTagContainer(const GameplayTags::FGameplayTagContainer& GameplayTagContainer, BasicTypes::TArray<GameplayTags::FGameplayTag>* GameplayTags)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.BreakGameplayTagContainer");
        
        UBlueprintGameplayTagLibrary_BreakGameplayTagContainer_Params params {};
        params.GameplayTagContainer = GameplayTagContainer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (GameplayTags != nullptr)
            *GameplayTags = params.GameplayTags;
    }

    /**
     * Function:
     *         RVA    -> 0x01053270
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.AppendGameplayTagContainers
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                InOutTagContainer                                          (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTagContainer                InTagContainer                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UBlueprintGameplayTagLibrary::STATIC_AppendGameplayTagContainers(GameplayTags::FGameplayTagContainer* InOutTagContainer, const GameplayTags::FGameplayTagContainer& InTagContainer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.AppendGameplayTagContainers");
        
        UBlueprintGameplayTagLibrary_AppendGameplayTagContainers_Params params {};
        params.InTagContainer = InTagContainer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (InOutTagContainer != nullptr)
            *InOutTagContainer = params.InOutTagContainer;
    }

    /**
     * Function:
     *         RVA    -> 0x01053170
     *         Name   -> Function /Script/GameplayTags.BlueprintGameplayTagLibrary.AddGameplayTag
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         GameplayTags::FGameplayTag                         Tag                                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UBlueprintGameplayTagLibrary::STATIC_AddGameplayTag(GameplayTags::FGameplayTagContainer* TagContainer, const GameplayTags::FGameplayTag& Tag)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.BlueprintGameplayTagLibrary.AddGameplayTag");
        
        UBlueprintGameplayTagLibrary_AddGameplayTag_Params params {};
        params.Tag = Tag;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (TagContainer != nullptr)
            *TagContainer = params.TagContainer;
    }

    /**
     * Function:
     *         RVA    -> 0x01054490
     *         Name   -> Function /Script/GameplayTags.GameplayTagAssetInterface.HasMatchingGameplayTag
     *         Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         GameplayTags::FGameplayTag                         TagToCheck                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool IGameplayTagAssetInterface::HasMatchingGameplayTag(const GameplayTags::FGameplayTag& TagToCheck)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.GameplayTagAssetInterface.HasMatchingGameplayTag");
        
        IGameplayTagAssetInterface_HasMatchingGameplayTag_Params params {};
        params.TagToCheck = TagToCheck;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01054240
     *         Name   -> Function /Script/GameplayTags.GameplayTagAssetInterface.HasAnyMatchingGameplayTags
     *         Flags  -> (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool IGameplayTagAssetInterface::HasAnyMatchingGameplayTags(const GameplayTags::FGameplayTagContainer& TagContainer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.GameplayTagAssetInterface.HasAnyMatchingGameplayTags");
        
        IGameplayTagAssetInterface_HasAnyMatchingGameplayTags_Params params {};
        params.TagContainer = TagContainer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01053ED0
     *         Name   -> Function /Script/GameplayTags.GameplayTagAssetInterface.HasAllMatchingGameplayTags
     *         Flags  -> (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool IGameplayTagAssetInterface::HasAllMatchingGameplayTags(const GameplayTags::FGameplayTagContainer& TagContainer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.GameplayTagAssetInterface.HasAllMatchingGameplayTags");
        
        IGameplayTagAssetInterface_HasAllMatchingGameplayTags_Params params {};
        params.TagContainer = TagContainer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x01053D70
     *         Name   -> Function /Script/GameplayTags.GameplayTagAssetInterface.GetOwnedGameplayTags
     *         Flags  -> (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         GameplayTags::FGameplayTagContainer                TagContainer                                               (Parm, OutParm, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void IGameplayTagAssetInterface::GetOwnedGameplayTags(GameplayTags::FGameplayTagContainer* TagContainer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/GameplayTags.GameplayTagAssetInterface.GetOwnedGameplayTags");
        
        IGameplayTagAssetInterface_GetOwnedGameplayTags_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (TagContainer != nullptr)
            *TagContainer = params.TagContainer;
    }

}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
