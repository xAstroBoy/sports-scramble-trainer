#pragma once

/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    SportsScramble              |
 * | Version: 1                           |
 * | Date:    09/09/2024                  |
 * ----------------------------------------
 */

#include <cstdint>
#include <vector>
#include <string>
#include "BasicTypes_FName.h"
#include "BasicTypes_TUObjectArray.h"

// --------------------------------------------------
// # Forwards
// --------------------------------------------------
namespace CG::CoreUObject { class UClass; };
namespace CG::CoreUObject { class UObject; };
namespace CG::CoreUObject { class UFunction; };

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::CoreUObject
{
    /**
     * Class /Script/CoreUObject.Object
     * Size -> 0x0028
     */
    class UObject
    {
    public:
        static BasicTypes::TUObjectArray*                            GObjects;                                                //  PREDEFINED PROPERTY
        void*                                                        VfTable;                                                 //  PREDEFINED PROPERTY
        int32_t                                                      Flags;                                                   //  PREDEFINED PROPERTY
        int32_t                                                      InternalIndex;                                           //  PREDEFINED PROPERTY
        CoreUObject::UClass*                                         Class;                                                   //  PREDEFINED PROPERTY
        BasicTypes::FName                                            Name;                                                    //  PREDEFINED PROPERTY
        CoreUObject::UObject*                                        Outer;                                                   //  PREDEFINED PROPERTY

    public:
        void ExecuteUbergraph(int32_t EntryPoint);
        void ProcessEvent(CoreUObject::UFunction* function, void* params);
        static BasicTypes::TUObjectArray& GetGlobalObjects();
        std::string GetName() const;
        std::string GetFullName() const;
        template<typename T>
        static T* FindObject(const std::string& name)
        {
            auto& gObjects = CoreUObject::UObject::GetGlobalObjects();
            for (int32_t i = 0; i < gObjects.Count(); ++i)
            {
                auto object = gObjects.GetByIndex(i);
            
                if (!object)
                    continue;
            
                if (object->GetFullName() == name)
                    return static_cast<T*>(object);
            }
            return nullptr;
        }
        template<typename T>
        static T* FindObject()
        {
            auto& gObjects = CoreUObject::UObject::GetGlobalObjects();
            auto v = T::StaticClass();
            for (int32_t i = 0; i < gObjects.Count(); ++i)
            {
                auto object = gObjects.GetByIndex(i);
            
                if (!object)
                    continue;
            
                if (object->IsA(v))
                    return static_cast<T*>(object);
            }
            return nullptr;
        }
        template<typename T>
        static std::vector<T*> FindObjects(const std::string& name)
        {
            auto& gObjects = CoreUObject::UObject::GetGlobalObjects();
            std::vector<T*> ret;
            for (int32_t i = 0; i < gObjects.Count(); ++i)
            {
                auto object = gObjects.GetByIndex(i);
            
                if (!object)
                    continue;
            
                if (object->GetFullName() == name)
                    ret.push_back(static_cast<T*>(object));
            }
            return ret;
        }
        template<typename T>
        static std::vector<T*> FindObjects()
        {
            std::vector<T*> ret;
            auto v = T::StaticClass();
            auto& gObjects = CoreUObject::UObject::GetGlobalObjects();
            for (int i = 0; i < gObjects.Count(); ++i)
            {
                auto object = gObjects.GetByIndex(i);
            
                if (!object)
                    continue;
            
                if (object->IsA(v))
                    ret.push_back(static_cast<T*>(object));
            }
            return ret;
        }
        static CoreUObject::UClass* FindClass(const std::string& name);
        template<typename T>
        static T* GetObjectCasted(size_t index)
        {
            return static_cast<T*>(CoreUObject::UObject::GetGlobalObjects().GetByIndex(index));
        }
        bool IsA(CoreUObject::UClass* cmp) const;
        static inline CoreUObject::UClass* StaticClass()
        {
            static CoreUObject::UClass* ptr = nullptr;
            if (!ptr)
                ptr = CoreUObject::UObject::FindClass("Class /Script/CoreUObject.Object");
            return ptr;
        }
    };
}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
