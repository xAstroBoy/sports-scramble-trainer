#pragma once

/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    SportsScramble              |
 * | Version: 1                           |
 * | Date:    09/09/2024                  |
 * ----------------------------------------
 */

#include <cstdint>
#include <vector>
#include <string>
#include "Engine_ENUMS.h"
#include "BasicTypes_UScriptMulticastDelegate.h"
#include "Engine_FAnimNotifyQueue.h"
#include "BasicTypes_TArray.h"
#include "Engine_FAnimNotifyEvent.h"
#include "CoreUObject_UObject.h"
#include "BasicTypes_FName.h"
#include "Engine_FPoseSnapshot.h"
#include "Engine_FMarkerSyncAnimPosition.h"
#include "CoreUObject_FVector.h"
#include "CoreUObject_FRotator.h"

// --------------------------------------------------
// # Forwards
// --------------------------------------------------
namespace CG::Engine { class USkeleton; };
namespace CG::Engine { class APawn; };
namespace CG::Engine { class UAnimSequenceBase; };
namespace CG::Engine { class UAnimMontage; };
namespace CG::Engine { class USkeletalMeshComponent; };
namespace CG::Engine { class AActor; };
namespace CG::CoreUObject { class UClass; };

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::Engine
{
    /**
     * Class /Script/Engine.AnimInstance
     * Size -> 0x0330 (FullSize[0x0358] - InheritedSize[0x0028])
     */
    class UAnimInstance : public CoreUObject::UObject
    {
    public:
        Engine::USkeleton*                                           CurrentSkeleton;                                         //  ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
        Engine::ERootMotionMode                                      RootMotionMode;                                          //  Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
        bool                                                         bUseMultiThreadedAnimationUpdate : 1;                    //  BIT_FIELD NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
        bool                                                         bUsingCopyPoseFromMesh : 1;                              //  BIT_FIELD NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic
        bool                                                         UnknownData_0000 : 1;                                    //  BIT_FIELD (PADDING)
        bool                                                         bQueueMontageEvents : 1;                                 //  BIT_FIELD Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate
        uint8_t                                                      UnknownData_0001[0x6];                                   //  MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
        BasicTypes::UScriptMulticastDelegate                         OnMontageBlendingOut;                                    //  ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic
        BasicTypes::UScriptMulticastDelegate                         OnMontageStarted;                                        //  ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic
        BasicTypes::UScriptMulticastDelegate                         OnMontageEnded;                                          //  ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic
        BasicTypes::UScriptMulticastDelegate                         OnAllMontageInstancesEnded;                              //  ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic
        uint8_t                                                      UnknownData_0002[0x80];                                  //  MISSED OFFSET (FIX SPACE BETWEEN PREVIOUS PROPERTY)
        Engine::FAnimNotifyQueue                                     NotifyQueue;                                             //  Transient, NativeAccessSpecifierPublic
        BasicTypes::TArray<Engine::FAnimNotifyEvent>                 ActiveAnimNotifyState;                                   //  ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic
        uint8_t                                                      UnknownData_0004[0x1E0];                                 //  Fix size for supers

    public:
        void UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic);
        Engine::APawn* TryGetPawnOwner();
        void StopSlotAnimation(float InBlendOutTime, const BasicTypes::FName& SlotNodeName);
        void SnapshotPose(Engine::FPoseSnapshot* Snapshot);
        void SetRootMotionMode(Engine::ERootMotionMode Value);
        void SetMorphTarget(const BasicTypes::FName& MorphTargetName, float Value);
        void SavePoseSnapshot(const BasicTypes::FName& SnapshotName);
        void ResetDynamics(Engine::ETeleportType InTeleportType);
        Engine::UAnimMontage* PlaySlotAnimationAsDynamicMontage(Engine::UAnimSequenceBase* Asset, const BasicTypes::FName& SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32_t LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
        float PlaySlotAnimation(Engine::UAnimSequenceBase* Asset, const BasicTypes::FName& SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32_t LoopCount);
        void Montage_Stop(float InBlendOutTime, Engine::UAnimMontage* Montage);
        void Montage_SetPosition(Engine::UAnimMontage* Montage, float NewPosition);
        void Montage_SetPlayRate(Engine::UAnimMontage* Montage, float NewPlayRate);
        void Montage_SetNextSection(const BasicTypes::FName& SectionNameToChange, const BasicTypes::FName& NextSection, Engine::UAnimMontage* Montage);
        void Montage_Resume(Engine::UAnimMontage* Montage);
        float Montage_Play(Engine::UAnimMontage* MontageToPlay, float InPlayRate, Engine::EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages);
        void Montage_Pause(Engine::UAnimMontage* Montage);
        void Montage_JumpToSectionsEnd(const BasicTypes::FName& SectionName, Engine::UAnimMontage* Montage);
        void Montage_JumpToSection(const BasicTypes::FName& SectionName, Engine::UAnimMontage* Montage);
        bool Montage_IsPlaying(Engine::UAnimMontage* Montage);
        bool Montage_IsActive(Engine::UAnimMontage* Montage);
        float Montage_GetPosition(Engine::UAnimMontage* Montage);
        float Montage_GetPlayRate(Engine::UAnimMontage* Montage);
        bool Montage_GetIsStopped(Engine::UAnimMontage* Montage);
        BasicTypes::FName Montage_GetCurrentSection(Engine::UAnimMontage* Montage);
        float Montage_GetBlendTime(Engine::UAnimMontage* Montage);
        void LockAIResources(bool bLockMovement, bool LockAILogic);
        bool IsSyncGroupBetweenMarkers(const BasicTypes::FName& InSyncGroupName, const BasicTypes::FName& PreviousMarker, const BasicTypes::FName& NextMarker, bool bRespectMarkerOrder);
        bool IsPlayingSlotAnimation(Engine::UAnimSequenceBase* Asset, const BasicTypes::FName& SlotNodeName);
        bool IsAnyMontagePlaying();
        bool HasMarkerBeenHitThisFrame(const BasicTypes::FName& SyncGroup, const BasicTypes::FName& MarkerName);
        bool GetTimeToClosestMarker(const BasicTypes::FName& SyncGroup, const BasicTypes::FName& MarkerName, float* OutMarkerTime);
        Engine::FMarkerSyncAnimPosition GetSyncGroupPosition(const BasicTypes::FName& InSyncGroupName);
        float GetRelevantAnimTimeRemainingFraction(int32_t MachineIndex, int32_t StateIndex);
        float GetRelevantAnimTimeRemaining(int32_t MachineIndex, int32_t StateIndex);
        float GetRelevantAnimTimeFraction(int32_t MachineIndex, int32_t StateIndex);
        float GetRelevantAnimTime(int32_t MachineIndex, int32_t StateIndex);
        float GetRelevantAnimLength(int32_t MachineIndex, int32_t StateIndex);
        Engine::USkeletalMeshComponent* GetOwningComponent();
        Engine::AActor* GetOwningActor();
        float GetInstanceTransitionTimeElapsedFraction(int32_t MachineIndex, int32_t TransitionIndex);
        float GetInstanceTransitionTimeElapsed(int32_t MachineIndex, int32_t TransitionIndex);
        float GetInstanceTransitionCrossfadeDuration(int32_t MachineIndex, int32_t TransitionIndex);
        float GetInstanceStateWeight(int32_t MachineIndex, int32_t StateIndex);
        float GetInstanceMachineWeight(int32_t MachineIndex);
        float GetInstanceCurrentStateElapsedTime(int32_t MachineIndex);
        float GetInstanceAssetPlayerTimeFromEndFraction(int32_t AssetPlayerIndex);
        float GetInstanceAssetPlayerTimeFromEnd(int32_t AssetPlayerIndex);
        float GetInstanceAssetPlayerTimeFraction(int32_t AssetPlayerIndex);
        float GetInstanceAssetPlayerTime(int32_t AssetPlayerIndex);
        float GetInstanceAssetPlayerLength(int32_t AssetPlayerIndex);
        float GetCurveValue(const BasicTypes::FName& CurveName);
        BasicTypes::FName GetCurrentStateName(int32_t MachineIndex);
        Engine::UAnimMontage* GetCurrentActiveMontage();
        void GetAllCurveNames(BasicTypes::TArray<BasicTypes::FName>* OutNames);
        void GetActiveCurveNames(Engine::EAnimCurveType CurveType, BasicTypes::TArray<BasicTypes::FName>* OutNames);
        void ClearMorphTargets();
        float CalculateDirection(const CoreUObject::FVector& Velocity, const CoreUObject::FRotator& BaseRotation);
        void BlueprintUpdateAnimation(float DeltaTimeX);
        void BlueprintPostEvaluateAnimation();
        void BlueprintInitializeAnimation();
        void BlueprintBeginPlay();
        static inline CoreUObject::UClass* StaticClass()
        {
            static CoreUObject::UClass* ptr = nullptr;
            if (!ptr)
                ptr = CoreUObject::UObject::FindClass("Class /Script/Engine.AnimInstance");
            return ptr;
        }
    };
}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
