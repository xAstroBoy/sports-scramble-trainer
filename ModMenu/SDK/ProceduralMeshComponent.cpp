/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    SportsScramble              |
 * | Version: 1                           |
 * | Date:    09/09/2024                  |
 * ----------------------------------------
 */

#include "../pch.h"
#include <cstdint>
#include <vector>
#include <string>
#include <locale>
#include <unordered_set>
#include "Headers/Global_DEFINES.h"
#include "Headers/BasicTypes.h"
#include "Headers/CoreUObject_UFunction.h"
#include "Headers/ProceduralMeshComponent_ENUMS.h"
#include "Headers/ProceduralMeshComponent_PARAMS.h"
#include "Headers/ProceduralMeshComponent_UKismetProceduralMeshLibrary.h"
#include "Headers/ProceduralMeshComponent_UProceduralMeshComponent.h"

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::ProceduralMeshComponent
{
    // --------------------------------------------------
    // # Structs functions
    // --------------------------------------------------
    /**
     * Function:
     *         RVA    -> 0x002C3BD0
     *         Name   -> Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.SliceProceduralMesh
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
     * Parameters:
     *         ProceduralMeshComponent::UProceduralMeshComponent* InProcMesh                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               PlanePosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               PlaneNormal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bCreateOtherHalf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         ProceduralMeshComponent::UProceduralMeshComponent* OutOtherHalfProcMesh                                       (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         ProceduralMeshComponent::EProcMeshSliceCapOption   CapOption                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::UMaterialInterface*                        CapMaterial                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UKismetProceduralMeshLibrary::STATIC_SliceProceduralMesh(ProceduralMeshComponent::UProceduralMeshComponent* InProcMesh, const CoreUObject::FVector& PlanePosition, const CoreUObject::FVector& PlaneNormal, bool bCreateOtherHalf, ProceduralMeshComponent::UProceduralMeshComponent** OutOtherHalfProcMesh, ProceduralMeshComponent::EProcMeshSliceCapOption CapOption, Engine::UMaterialInterface* CapMaterial)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.SliceProceduralMesh");
        
        UKismetProceduralMeshLibrary_SliceProceduralMesh_Params params {};
        params.InProcMesh = InProcMesh;
        params.PlanePosition = PlanePosition;
        params.PlaneNormal = PlaneNormal;
        params.bCreateOtherHalf = bCreateOtherHalf;
        params.CapOption = CapOption;
        params.CapMaterial = CapMaterial;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutOtherHalfProcMesh != nullptr)
            *OutOtherHalfProcMesh = params.OutOtherHalfProcMesh;
    }

    /**
     * Function:
     *         RVA    -> 0x002C3790
     *         Name   -> Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.GetSectionFromStaticMesh
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::UStaticMesh*                               InMesh                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            LODIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Vertices                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<int32_t>                        Triangles                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Normals                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UVs                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UKismetProceduralMeshLibrary::STATIC_GetSectionFromStaticMesh(Engine::UStaticMesh* InMesh, int32_t LODIndex, int32_t SectionIndex, BasicTypes::TArray<CoreUObject::FVector>* Vertices, BasicTypes::TArray<int32_t>* Triangles, BasicTypes::TArray<CoreUObject::FVector>* Normals, BasicTypes::TArray<CoreUObject::FVector2D>* UVs, BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent>* Tangents)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.GetSectionFromStaticMesh");
        
        UKismetProceduralMeshLibrary_GetSectionFromStaticMesh_Params params {};
        params.InMesh = InMesh;
        params.LODIndex = LODIndex;
        params.SectionIndex = SectionIndex;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Vertices != nullptr)
            *Vertices = params.Vertices;
        if (Triangles != nullptr)
            *Triangles = params.Triangles;
        if (Normals != nullptr)
            *Normals = params.Normals;
        if (UVs != nullptr)
            *UVs = params.UVs;
        if (Tangents != nullptr)
            *Tangents = params.Tangents;
    }

    /**
     * Function:
     *         RVA    -> 0x002C34E0
     *         Name   -> Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.GetSectionFromProceduralMesh
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         ProceduralMeshComponent::UProceduralMeshComponent* InProcMesh                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Vertices                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<int32_t>                        Triangles                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Normals                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UVs                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UKismetProceduralMeshLibrary::STATIC_GetSectionFromProceduralMesh(ProceduralMeshComponent::UProceduralMeshComponent* InProcMesh, int32_t SectionIndex, BasicTypes::TArray<CoreUObject::FVector>* Vertices, BasicTypes::TArray<int32_t>* Triangles, BasicTypes::TArray<CoreUObject::FVector>* Normals, BasicTypes::TArray<CoreUObject::FVector2D>* UVs, BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent>* Tangents)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.GetSectionFromProceduralMesh");
        
        UKismetProceduralMeshLibrary_GetSectionFromProceduralMesh_Params params {};
        params.InProcMesh = InProcMesh;
        params.SectionIndex = SectionIndex;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Vertices != nullptr)
            *Vertices = params.Vertices;
        if (Triangles != nullptr)
            *Triangles = params.Triangles;
        if (Normals != nullptr)
            *Normals = params.Normals;
        if (UVs != nullptr)
            *UVs = params.UVs;
        if (Tangents != nullptr)
            *Tangents = params.Tangents;
    }

    /**
     * Function:
     *         RVA    -> 0x002C3220
     *         Name   -> Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.GenerateBoxMesh
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
     * Parameters:
     *         CoreUObject::FVector                               BoxRadius                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Vertices                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<int32_t>                        Triangles                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Normals                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UVs                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UKismetProceduralMeshLibrary::STATIC_GenerateBoxMesh(const CoreUObject::FVector& BoxRadius, BasicTypes::TArray<CoreUObject::FVector>* Vertices, BasicTypes::TArray<int32_t>* Triangles, BasicTypes::TArray<CoreUObject::FVector>* Normals, BasicTypes::TArray<CoreUObject::FVector2D>* UVs, BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent>* Tangents)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.GenerateBoxMesh");
        
        UKismetProceduralMeshLibrary_GenerateBoxMesh_Params params {};
        params.BoxRadius = BoxRadius;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Vertices != nullptr)
            *Vertices = params.Vertices;
        if (Triangles != nullptr)
            *Triangles = params.Triangles;
        if (Normals != nullptr)
            *Normals = params.Normals;
        if (UVs != nullptr)
            *UVs = params.UVs;
        if (Tangents != nullptr)
            *Tangents = params.Tangents;
    }

    /**
     * Function:
     *         RVA    -> 0x002C2900
     *         Name   -> Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.CreateGridMeshTriangles
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         int32_t                                            NumX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            NumY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bWinding                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<int32_t>                        Triangles                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UKismetProceduralMeshLibrary::STATIC_CreateGridMeshTriangles(int32_t NumX, int32_t NumY, bool bWinding, BasicTypes::TArray<int32_t>* Triangles)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.CreateGridMeshTriangles");
        
        UKismetProceduralMeshLibrary_CreateGridMeshTriangles_Params params {};
        params.NumX = NumX;
        params.NumY = NumY;
        params.bWinding = bWinding;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Triangles != nullptr)
            *Triangles = params.Triangles;
    }

    /**
     * Function:
     *         RVA    -> 0x002C27D0
     *         Name   -> Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.CopyProceduralMeshFromStaticMeshComponent
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable)
     * Parameters:
     *         Engine::UStaticMeshComponent*                      StaticMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            LODIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         ProceduralMeshComponent::UProceduralMeshComponent* ProcMeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bCreateCollision                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UKismetProceduralMeshLibrary::STATIC_CopyProceduralMeshFromStaticMeshComponent(Engine::UStaticMeshComponent* StaticMeshComponent, int32_t LODIndex, ProceduralMeshComponent::UProceduralMeshComponent* ProcMeshComponent, bool bCreateCollision)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.CopyProceduralMeshFromStaticMeshComponent");
        
        UKismetProceduralMeshLibrary_CopyProceduralMeshFromStaticMeshComponent_Params params {};
        params.StaticMeshComponent = StaticMeshComponent;
        params.LODIndex = LODIndex;
        params.ProcMeshComponent = ProcMeshComponent;
        params.bCreateCollision = bCreateCollision;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x002C2630
     *         Name   -> Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.ConvertQuadToTriangles
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         BasicTypes::TArray<int32_t>                        Triangles                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         int32_t                                            Vert0                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            Vert1                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            Vert2                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            Vert3                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UKismetProceduralMeshLibrary::STATIC_ConvertQuadToTriangles(BasicTypes::TArray<int32_t>* Triangles, int32_t Vert0, int32_t Vert1, int32_t Vert2, int32_t Vert3)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.ConvertQuadToTriangles");
        
        UKismetProceduralMeshLibrary_ConvertQuadToTriangles_Params params {};
        params.Vert0 = Vert0;
        params.Vert1 = Vert1;
        params.Vert2 = Vert2;
        params.Vert3 = Vert3;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Triangles != nullptr)
            *Triangles = params.Triangles;
    }

    /**
     * Function:
     *         RVA    -> 0x002C2330
     *         Name   -> Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.CalculateTangentsForMesh
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         BasicTypes::TArray<CoreUObject::FVector>           Vertices                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<int32_t>                        Triangles                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UVs                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Normals                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UKismetProceduralMeshLibrary::STATIC_CalculateTangentsForMesh(BasicTypes::TArray<CoreUObject::FVector> Vertices, BasicTypes::TArray<int32_t> Triangles, BasicTypes::TArray<CoreUObject::FVector2D> UVs, BasicTypes::TArray<CoreUObject::FVector>* Normals, BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent>* Tangents)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.KismetProceduralMeshLibrary.CalculateTangentsForMesh");
        
        UKismetProceduralMeshLibrary_CalculateTangentsForMesh_Params params {};
        params.Vertices = Vertices;
        params.Triangles = Triangles;
        params.UVs = UVs;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Normals != nullptr)
            *Normals = params.Normals;
        if (Tangents != nullptr)
            *Tangents = params.Tangents;
    }

    /**
     * Function:
     *         RVA    -> 0x002C40C0
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.UpdateMeshSection_LinearColor
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Vertices                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Normals                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UV0                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UV1                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UV2                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UV3                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FLinearColor>      VertexColors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UProceduralMeshComponent::UpdateMeshSection_LinearColor(int32_t SectionIndex, BasicTypes::TArray<CoreUObject::FVector> Vertices, BasicTypes::TArray<CoreUObject::FVector> Normals, BasicTypes::TArray<CoreUObject::FVector2D> UV0, BasicTypes::TArray<CoreUObject::FVector2D> UV1, BasicTypes::TArray<CoreUObject::FVector2D> UV2, BasicTypes::TArray<CoreUObject::FVector2D> UV3, BasicTypes::TArray<CoreUObject::FLinearColor> VertexColors, BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.UpdateMeshSection_LinearColor");
        
        UProceduralMeshComponent_UpdateMeshSection_LinearColor_Params params {};
        params.SectionIndex = SectionIndex;
        params.Vertices = Vertices;
        params.Normals = Normals;
        params.UV0 = UV0;
        params.UV1 = UV1;
        params.UV2 = UV2;
        params.UV3 = UV3;
        params.VertexColors = VertexColors;
        params.Tangents = Tangents;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x002C3E00
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.UpdateMeshSection
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Vertices                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Normals                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UV0                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FColor>            VertexColors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UProceduralMeshComponent::UpdateMeshSection(int32_t SectionIndex, BasicTypes::TArray<CoreUObject::FVector> Vertices, BasicTypes::TArray<CoreUObject::FVector> Normals, BasicTypes::TArray<CoreUObject::FVector2D> UV0, BasicTypes::TArray<CoreUObject::FColor> VertexColors, BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.UpdateMeshSection");
        
        UProceduralMeshComponent_UpdateMeshSection_Params params {};
        params.SectionIndex = SectionIndex;
        params.Vertices = Vertices;
        params.Normals = Normals;
        params.UV0 = UV0;
        params.VertexColors = VertexColors;
        params.Tangents = Tangents;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x002C3B10
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.SetMeshSectionVisible
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bNewVisibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UProceduralMeshComponent::SetMeshSectionVisible(int32_t SectionIndex, bool bNewVisibility)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.SetMeshSectionVisible");
        
        UProceduralMeshComponent_SetMeshSectionVisible_Params params {};
        params.SectionIndex = SectionIndex;
        params.bNewVisibility = bNewVisibility;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x002C3A80
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.IsMeshSectionVisible
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UProceduralMeshComponent::IsMeshSectionVisible(int32_t SectionIndex)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.IsMeshSectionVisible");
        
        UProceduralMeshComponent_IsMeshSectionVisible_Params params {};
        params.SectionIndex = SectionIndex;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x002C34B0
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.GetNumSections
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UProceduralMeshComponent::GetNumSections()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.GetNumSections");
        
        UProceduralMeshComponent_GetNumSections_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x002C2DB0
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.CreateMeshSection_LinearColor
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Vertices                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<int32_t>                        Triangles                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Normals                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UV0                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UV1                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UV2                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UV3                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FLinearColor>      VertexColors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               bCreateCollision                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UProceduralMeshComponent::CreateMeshSection_LinearColor(int32_t SectionIndex, BasicTypes::TArray<CoreUObject::FVector> Vertices, BasicTypes::TArray<int32_t> Triangles, BasicTypes::TArray<CoreUObject::FVector> Normals, BasicTypes::TArray<CoreUObject::FVector2D> UV0, BasicTypes::TArray<CoreUObject::FVector2D> UV1, BasicTypes::TArray<CoreUObject::FVector2D> UV2, BasicTypes::TArray<CoreUObject::FVector2D> UV3, BasicTypes::TArray<CoreUObject::FLinearColor> VertexColors, BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents, bool bCreateCollision)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.CreateMeshSection_LinearColor");
        
        UProceduralMeshComponent_CreateMeshSection_LinearColor_Params params {};
        params.SectionIndex = SectionIndex;
        params.Vertices = Vertices;
        params.Triangles = Triangles;
        params.Normals = Normals;
        params.UV0 = UV0;
        params.UV1 = UV1;
        params.UV2 = UV2;
        params.UV3 = UV3;
        params.VertexColors = VertexColors;
        params.Tangents = Tangents;
        params.bCreateCollision = bCreateCollision;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x002C2A60
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.CreateMeshSection
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Vertices                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<int32_t>                        Triangles                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector>           Normals                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FVector2D>         UV0                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<CoreUObject::FColor>            VertexColors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         bool                                               bCreateCollision                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UProceduralMeshComponent::CreateMeshSection(int32_t SectionIndex, BasicTypes::TArray<CoreUObject::FVector> Vertices, BasicTypes::TArray<int32_t> Triangles, BasicTypes::TArray<CoreUObject::FVector> Normals, BasicTypes::TArray<CoreUObject::FVector2D> UV0, BasicTypes::TArray<CoreUObject::FColor> VertexColors, BasicTypes::TArray<ProceduralMeshComponent::FProcMeshTangent> Tangents, bool bCreateCollision)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.CreateMeshSection");
        
        UProceduralMeshComponent_CreateMeshSection_Params params {};
        params.SectionIndex = SectionIndex;
        params.Vertices = Vertices;
        params.Triangles = Triangles;
        params.Normals = Normals;
        params.UV0 = UV0;
        params.VertexColors = VertexColors;
        params.Tangents = Tangents;
        params.bCreateCollision = bCreateCollision;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x002C25B0
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.ClearMeshSection
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UProceduralMeshComponent::ClearMeshSection(int32_t SectionIndex)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.ClearMeshSection");
        
        UProceduralMeshComponent_ClearMeshSection_Params params {};
        params.SectionIndex = SectionIndex;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x002C2590
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.ClearCollisionConvexMeshes
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         void                                               ReturnValue
     */
    void UProceduralMeshComponent::ClearCollisionConvexMeshes()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.ClearCollisionConvexMeshes");
        
        UProceduralMeshComponent_ClearCollisionConvexMeshes_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x002C2570
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.ClearAllMeshSections
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         void                                               ReturnValue
     */
    void UProceduralMeshComponent::ClearAllMeshSections()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.ClearAllMeshSections");
        
        UProceduralMeshComponent_ClearAllMeshSections_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x002C2240
     *         Name   -> Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.AddCollisionConvexMesh
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         BasicTypes::TArray<CoreUObject::FVector>           ConvexVerts                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UProceduralMeshComponent::AddCollisionConvexMesh(BasicTypes::TArray<CoreUObject::FVector> ConvexVerts)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/ProceduralMeshComponent.ProceduralMeshComponent.AddCollisionConvexMesh");
        
        UProceduralMeshComponent_AddCollisionConvexMesh_Params params {};
        params.ConvexVerts = ConvexVerts;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
